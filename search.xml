<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/30/hello-world/"/>
      <url>2021/04/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Contaniners - [vector][heap]</title>
      <link href="2021/03/29/STLSourceCodeAnalysis_1/"/>
      <url>2021/03/29/STLSourceCodeAnalysis_1/</url>
      
        <content type="html"><![CDATA[<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>vector的数据安排以及操作方式，与array非常相似。两者唯一的差别在于<strong>空间运用的灵活性</strong>。array是静态空间，一旦配置了就不能改变。vector是<strong>动态空间</strong>，随着元素的加入，他的内部机制会自行扩充空间以及容纳新元素。</p><p>vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。一旦vector旧有空间满载，如果客户端每新增一个元素，vector内部只是扩充一个元素的空间，实为不明智，因为所谓扩充空间（不论多大），是<strong>“配置新空间  / 数据移动 / 释放旧空间”</strong>的一系列操作，时间成本很高，应加入某种未雨绸缪的考虑。</p><h3 id="2、迭代器"><a href="#2、迭代器" class="headerlink" title="2、迭代器"></a>2、迭代器</h3><p>vector维护的是一个连续线性空间，所以无论器元素类型是什么，普通指针都可以作为vector的迭代器而满足所有必要的条件。vector支持随机存储，普通指针正是有着这样的能力的，所以vector提供的是**<strong>Random Access iterators</strong>**。</p><span id="more"></span><h3 id="3、数据结构"><a href="#3、数据结构" class="headerlink" title="3、数据结构"></a>3、数据结构</h3><p>vector采用的数据结构是线性连续控件。它以两个迭代器*<strong>start</strong><em>和</em><strong>finish</strong><em>分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器</em><strong>end_of_storage</strong>*指向整块连续空间（含备份空间）的尾端。</p><pre><code class="cpp">tmplate&lt;class T, class Alloc = alloc&gt;class vector&#123;...protected:    iterator start;                //表示目前使用空间的头    iterator end;                //表示目前使用空间的尾    iterator end_of_storage;    //表示目前可用空间的尾...&#125;</code></pre><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这边是<strong>容量（capacity）</strong>的观念。如下图所示。</p><p><img src="https://i.loli.net/2021/03/29/X2IEQPbznlGrAB8.png" alt="stl-vector.png"></p><p>运用start，finish，end_of_storage三个迭代器，便可轻易地提供首尾标识、大小、容量、空容器判断等等机能。</p><pre><code class="c++">tmplate&lt;class T, class Alloc = alloc&gt;class vector&#123;...public:    iterator begin() &#123;return start;&#125;    iterator end() &#123;return finish;&#125;    size_type size() const &#123;return size_type( end() - being() );&#125;    size_type capacity() const &#123;        return size_type( end_of_storage - begin() );    &#125;    bool empty() const &#123;return begin() == end();&#125;        reference front() &#123;return *begin();&#125;    reference back() &#123;return *(end() - 1);&#125;...&#125;</code></pre><p>关于容量，有一点想要说明。增加新元素（s）时，如果超过当时的容量，则用量会扩充至两倍。如果两倍容量仍不足，就扩张至足够大的容量。容量的扩张必须经历<strong>“重新配置、元素移动、释放原空间”</strong>等过程。</p><p>所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可控配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始再原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>heap并不属于STL容器组件，他和*<strong>priority queue</strong>*相关。priority queue允许以任何次序将任何元素推进容器内，但是取出时一定是以优先权最高（也就是数值最高）的元素开始取。</p><p>将binary heap 作为 priority queue 的底层机制。</p><p>所谓的binary heap就是一种完全二叉树，也就是说整颗binary tree除了最底层的叶节点之外，是填满的，而最底层的叶节点由左到右又不得有空隙。如下图所示一个完全的二叉树以及array表达式：</p><p><img src="https://i.loli.net/2021/04/08/uWp5qFPJ1RCLScr.png" alt="binaryheap.png"></p><p>完全二叉树有一个最大的好处就是整棵树内没有任何节点漏洞，这就可以用array来存储所有的节点。为了后续的方便计算，将array的#0的位置设置为无限大值或者是无限小值，那么当完全二叉树中的某个节点位于array的i处时，他的左节点必定是位于array的2i处，他的右节点必定位于array的2i+1处，其父节点必定位于（i/2）处，通过这样的一个简单的位置规则，array可以轻易的实现出完全二叉树。事实上，上述vector可以完美替代array。</p><p>根据元素的排列方式，heap可以氛围max-heap和min-heap两种，前者每个节点的键值（key）都大于或者等于其子节点键值。后者的每个节点的键值（key）都小于或者等于其子节点键值。因此，max-heap的最大值在根节点，并总是位于底层array或者vector的开始处；min-heap的最小值在根节点，并总是位于底层array或者vector的开始处；STL提供的是max-heap。</p><h3 id="2、heap算法"><a href="#2、heap算法" class="headerlink" title="2、heap算法"></a>2、heap算法</h3><h4 id="1、push-heap算法"><a href="#1、push-heap算法" class="headerlink" title="1、push_heap算法"></a>1、push_heap算法</h4><pre><code class="c++">void shiftUp(int k)&#123;        //循环判定末尾节点是否大于其父节点        //大于其父节点，则当前节点和父节点交换以满足大顶堆的性质        //直至直至判定到根节点        while(k &gt; 1 &amp;&amp; data[k] &gt; data[k / 2])&#123;            swap(data[k], data[k / 2]);            k /= 2;        &#125;    &#125;</code></pre><p>push_heap的算法是指将新来的元素加入到堆中去，该堆所要进行的调整。</p><p>push_heap算法的主要步骤：</p><p>1、将新增的节点加在连续空间的最后面。</p><p>2、将新增的节点“上溯”。</p><p>3、继续调整节点所在子树，使其满足父节点始终大于子节点。</p><h4 id="2、pop-heap算法"><a href="#2、pop-heap算法" class="headerlink" title="2、pop_heap算法"></a>2、pop_heap算法</h4><pre><code class="c++">void shiftDown(int k)&#123;        while(2 * k &lt;= count)&#123;            int left = 2 * k;            int right = left + 1;            int mark = left;            if(right &lt;= count &amp;&amp; data[right] &gt; data[left])&#123;                mark = right;            &#125;            if(data[k] &gt; data[mark]) break;            swap(data[k], data[mark]);            k = mark;        &#125;    &#125;</code></pre><p>pop_heap的算法是指将首元素从堆中删除的操作，以及该堆所要进行的调整。</p><p>pop_heap算法的主要步骤：</p><p>1、将收尾元素互换，删除尾元素（所谓删除尾元素即把堆中“游标”移位）</p><p>2、将首元素进行“下溯”操作</p><p>3、找到子节点的最大值的节点</p><h3 id="3、heap没有迭代器"><a href="#3、heap没有迭代器" class="headerlink" title="3、heap没有迭代器"></a>3、heap没有迭代器</h3><p>heap的所有元素都必须遵循特别的（完全二叉树）的排列规则，所以heap不提供遍历功能，也不提供迭代器。</p><h3 id="4、堆的实现"><a href="#4、堆的实现" class="headerlink" title="4、堆的实现"></a>4、堆的实现</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cassert&gt;using namespace std;template&lt;typename Item&gt;class MaxHeap&#123;private:    Item *data;    int count;    int capacity;        void shiftUp(int k)&#123;        while(k &gt; 1 &amp;&amp; data[k] &gt; data[k / 2])&#123;            swap(data[k], data[k / 2]);            k /= 2;        &#125;    &#125;        void shiftDown(int k)&#123;        while(2 * k &lt;= count)&#123;            int left = 2 * k;            int right = left + 1;            int mark = left;            if(right &lt;= count &amp;&amp; data[right] &gt; data[left])&#123;                mark = right;            &#125;            if(data[k] &gt; data[mark]) break;            swap(data[k], data[mark]);            k = mark;        &#125;    &#125;        public:    MaxHeap(int capacity)&#123;        data = new Item[capacity + 1];        this-&gt;capacity = capacity;        count = 0;    &#125;        ~MaxHeap()&#123;        delete [] data;    &#125;        int size()&#123;        return count;    &#125;        bool isEmpty()&#123;        return count == 0;    &#125;        void insert(Item item)&#123;        assert(count + 1 &lt;= capacity);        data[count + 1] = item;        count++;        shiftUp(count);    &#125;        Item extractMax()&#123;        assert(count &gt; 0);        Item item = data[1];        swap(data[1], data[count]);        count--;        shiftDown(1);        return item;    &#125;        Item getMax()&#123;        assert(count &gt; 0);        return data[1];    &#125;    &#125;;int main()&#123;        MaxHeap&lt;int &gt; maxheap = MaxHeap&lt;int &gt;(10);        maxheap.insert(4);    maxheap.insert(9);    maxheap.insert(7);    maxheap.insert(3);    maxheap.insert(5);    maxheap.insert(1);    maxheap.insert(2);    maxheap.insert(8);        int size = maxheap.size();        for(int i = 0; i &lt; size; i++)&#123;        cout &lt;&lt; &quot;The maxheap item is &quot; &lt;&lt; maxheap.extractMax() &lt;&lt; endl;    &#125;        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> STL源码分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>卓有成效的管理者（1）</title>
      <link href="2021/03/20/WhyChooseToRead/"/>
      <url>2021/03/20/WhyChooseToRead/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-03-20摘录："><a href="#2021-03-20摘录：" class="headerlink" title="2021-03-20摘录："></a>2021-03-20摘录：</h1><p>1、如何<strong>自我管理</strong>才能成为卓有成效的管理者。</p><p>2、管理者做事必须有效。</p><p>3、知识工作者本人必须自己管理自己，自觉地完成任务，自觉地做出贡献，自觉地追求工作效益。</p><p>4、如果他的工作缺少有效性，那么他对做好工作和做出贡献的热情很快就会消退，他将成为朝九晚五在办公室消磨时间的人。</p><span id="more"></span><h1 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h1><h2 id="一、自我管理"><a href="#一、自我管理" class="headerlink" title="一、自我管理"></a>一、自我管理</h2><p>这方面我个人是有尝试过的。比如规范自我的生活习惯，小到每日的饮食、作息，大到每周的学习任务，再如工作中的情绪管理。上述的两次尝试让我深刻的感觉自己的自我约束能力有待加强，人的惰性的还是很大的，需要借助一定的外力或者精神上的目标来激励自己。习惯容易养成，但也不容易养成，这取决于个人的意志是否足够强大，强大到能够用理智来决定个人的行为。如果是单纯的制定每周的学习任务，没有一个明确的目标作为指导，这样的学习就会显得没有目标，哪怕是这样的目标是读完一本书，也会比没有目标的学习更有成效。我始终觉得，个人的情绪管理在工作中异常的重要。之前有读过项目管理的相关书籍，里面有谈到什么是情商，我认为解释的很好，也确实让我对情商有了不同且较为深入的理解。</p><blockquote><p> 情商，也叫情绪智商。主要包括两大方面，一是意识到自己情绪的变化，并能控制自己情绪的能力。二是意识到旁人情绪的变化，并能及时调整，顾及到旁人感受的能力。</p></blockquote><p>不喜欢合作，不愿意沟通，脾气急躁且容易动怒，都表示一个人的情商很低，这不利于我们在日常工作中处理人际关系。工作上经常遇到情绪失控的事情，这是正常的，难免会遇到思考方式以及解决问题的思路不一样的人，但自己如何控制自己的情绪就是很重要的一件事。</p><blockquote><p>1、暂时放下自己的观点，多倾听别人的想法。</p><p>2、通过换位思考的方式，让自己更多的了解别人的感受，这样可以减少自己对别人情绪的忽视。</p><p>3、深呼吸，不要急于在人面前表达自己愤怒的情绪，尝试缓和自己的情绪。</p><p>4、事后冷静思考面对情绪失控场景时自己的行为，警惕自己下次不要再次陷入情绪中，用分析思考代替盲目冲动。</p></blockquote><p>自我管理是个需要长期进行的一个过程，也是一个需要长期学习的过程。也就是说长期自我管理，长期学习自我管理。</p><h2 id="二、工作有效性"><a href="#二、工作有效性" class="headerlink" title="二、工作有效性"></a>二、工作有效性</h2><p>所谓工作有效性，就是“做好该做的事情”的能力。</p><p>通常，我们是具备这样的能力的，但是却不代表我们永远具备这样的能力。作为代码开发者，我们整个职业生涯都伴随着学习，因为技术的更新异常的快，可能无法站在技术的前沿，但是决不能让自己落在队伍的后面。我们不仅仅是为了满足有这样的能力，也是为了自身的能力的提升。</p><p>就我个人而言，工作的两三年积累虽然也是较为客观，但是始终无法形成自己的东西。我可能会在生产环境使用Redis、ElasticSearch、Nginx、RocketMQ等等，但是我们仅仅停留在使用，没有进一步的深入了解到他们的运作原理，这也是我以后学习的重点方向。好记性不如烂笔头，多看几次也不如形成文件的记录下来，温故而知新。所以，后续在Hexo搭建的个人平台上也会多多记录这些内容，这样的内容记录是基于书本上的，因为书本是知识的来源。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Clover</title>
      <link href="2021/03/13/Clover/"/>
      <url>2021/03/13/Clover/</url>
      
        <content type="html"><![CDATA[<p>#Test</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
